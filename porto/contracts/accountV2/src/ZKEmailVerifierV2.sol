// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

/// @notice Interface for the zkEmail circuit verifier
/// @dev Matches the verifier generated by snarkjs/circom
interface IGroth16Verifier {
    /// @notice Verifies a Groth16 proof
    /// @param a First component of the proof (G1 point)
    /// @param b Second component of the proof (G2 point)
    /// @param c Third component of the proof (G1 point)
    /// @param input Public inputs to the circuit
    /// @return True if the proof is valid
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[11] memory input
    ) external view returns (bool);
}

/// @title ZKEmailVerifierV2
/// @author Porto Team
/// @notice Verifier contract for zkEmail proofs with Groth16 integration
/// @dev Integrates with the circuit verifier at email-infrastructure/circuit/verifier.sol
contract ZKEmailVerifierV2 {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           STRUCTS                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Structure for Groth16 proof components
    /// @dev Matches the format expected by the circuit verifier
    struct Groth16Proof {
        uint256[2] a;           // First component (G1 point)
        uint256[2][2] b;        // Second component (G2 point)
        uint256[2] c;           // Third component (G1 point)
    }

    /// @notice Structure for email proof with circuit inputs
    /// @dev Contains both the proof and the public inputs for verification
    struct EmailProof {
        Groth16Proof proof;      // The Groth16 proof components
        uint256[11] publicInputs; // The 11 public inputs expected by circuit
    }

    /// @notice Structure for verified email data
    struct VerifiedEmail {
        address recipient;       // Account that verified this email
        string emailAddress;     // The verified email address
        uint256 timestamp;       // When the verification occurred
        bytes32 nullifier;      // Prevent replay attacks
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                             */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice The Groth16 verifier contract
    /// @dev Set during deployment to the circuit verifier address
    IGroth16Verifier public immutable groth16Verifier;

    /// @notice Mapping from nullifier to verification status
    mapping(bytes32 => bool) public usedNullifiers;

    /// @notice Mapping from account to verified email
    mapping(address => VerifiedEmail) public verifiedEmails;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                             */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    event EmailVerified(
        address indexed account,
        string emailAddress,
        uint256 timestamp,
        bytes32 nullifier
    );

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CUSTOM ERRORS                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @custom:error Proof verification failed on-chain
    error InvalidProof();
    /// @custom:error This proof has already been used
    error ProofAlreadyUsed();
    /// @custom:error Email already verified for this account
    error EmailAlreadyVerified();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         CONSTRUCTOR                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Deploys the verifier with a reference to the Groth16 contract
    /// @param _groth16Verifier Address of the deployed circuit verifier
    constructor(address _groth16Verifier) {
        groth16Verifier = IGroth16Verifier(_groth16Verifier);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     VERIFICATION LOGIC                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Verifies an email proof and stores the verification
    /// @dev Calls the Groth16 verifier with the proof components and public inputs
    /// @param proof The email proof containing Groth16 components and public inputs
    /// @param emailAddress The email address being verified (for storage)
    /// @return success Whether the verification was successful
    function verifyEmailProof(
        EmailProof calldata proof,
        string calldata emailAddress
    ) external returns (bool success) {
        // Calculate nullifier from proof's public inputs to prevent replay
        bytes32 nullifier = keccak256(abi.encode(proof.publicInputs));

        // Check if proof has already been used
        if (usedNullifiers[nullifier]) {
            revert ProofAlreadyUsed();
        }

        // Check if account already has a verified email
        if (bytes(verifiedEmails[msg.sender].emailAddress).length > 0) {
            revert EmailAlreadyVerified();
        }

        // Call the Groth16 verifier with proof components
        bool valid = groth16Verifier.verifyProof(
            proof.proof.a,
            proof.proof.b,
            proof.proof.c,
            proof.publicInputs
        );

        if (!valid) {
            revert InvalidProof();
        }

        // Mark nullifier as used
        usedNullifiers[nullifier] = true;

        // Store verified email
        verifiedEmails[msg.sender] = VerifiedEmail({
            recipient: msg.sender,
            emailAddress: emailAddress,
            timestamp: block.timestamp,
            nullifier: nullifier
        });

        emit EmailVerified(msg.sender, emailAddress, block.timestamp, nullifier);

        return true;
    }

    /// @notice Gets the verified email for an account
    /// @param account The account to check
    /// @return The verified email data
    function getVerifiedEmail(address account) external view returns (VerifiedEmail memory) {
        return verifiedEmails[account];
    }

    /// @notice Checks if an email is verified for an account
    /// @dev Returns true if the account has a non-empty email address stored
    /// @param account The account to check
    /// @return Whether the account has a verified email
    function isEmailVerified(address account) external view returns (bool) {
        return bytes(verifiedEmails[account].emailAddress).length > 0;
    }

    /// @notice Checks if a nullifier has been used
    /// @dev Useful for preventing replay attacks
    /// @param nullifier The nullifier to check
    /// @return Whether the nullifier has been used
    function isNullifierUsed(bytes32 nullifier) external view returns (bool) {
        return usedNullifiers[nullifier];
    }

    /// @notice Computes the nullifier for a given proof
    /// @dev Can be called off-chain to predict the nullifier
    /// @param publicInputs The public inputs of the proof
    /// @return The computed nullifier
    function computeNullifier(uint256[11] calldata publicInputs) external pure returns (bytes32) {
        return keccak256(abi.encode(publicInputs));
    }
}