import { Example } from '../../../components/guides/Siwe'
import { GuideDemoContainer } from '../../../components/GuideDemoContainer'

# Authentication (SIWE)

## Example

<GuideDemoContainer src="ithacaxyz/porto/tree/main/examples/authentication">
  <Example />
</GuideDemoContainer>

## Steps

::::steps

### Connect Account

Follow the [Onboard & Discover Accounts](/sdk/guides/discover-accounts) guide to get this set up.

### Setup API & add `/siwe/nonce`

Next, we will set up our API endpoints for our authentication flow.

Sign in with Ethereum [requires a nonce](https://eips.ethereum.org/EIPS/eip-4361#message-fields) to be generated by the server to prevent replay attacks. You will need to set up a API endpoint to return a nonce. For example, using [Hono](https://hono.dev) and [Viem](https://viem.sh).

:::note
We will cover the other endpoints (e.g. `/siwe`, etc) in the next steps.
:::

```ts
import { Hono } from 'hono'
import { Porto } from 'porto'
import { generateSiweNonce } from 'viem/siwe'

const app = new Hono().basePath('/api')
const porto = Porto.create()

app.post('/siwe/nonce', (c) => c.json({ nonce: generateSiweNonce() }))

app.post('/siwe/verify', async (c) => { /* ... */ })

app.post('/siwe/logout', async (c) => { /* ... */ })

app.get('/me', async (c) => { /* ... */ })

export default app
```

### Add `/siwe/verify`

We will now implement the `/api/siwe` endpoint so that we can authenticate our user provided
the `siwe` response from the previous step is valid.

:::note
We are using `hono/cookie` and `hono/jwt` as our auth mechanism to issue a JWT for the user in a HTTP-only cookie.
:::

:::warning
This is an naive implementation of an authentication endpoint. In production, you will need to perform additional
checks on the SIWE message, nonce, token expiration, etc. For a complete example, see the [Authentication example](https://github.com/ithacaxyz/porto/blob/main/examples/authentication/worker/index.ts).
:::

```ts
import { Hono } from 'hono'
import { setCookie } from 'hono/cookie' // [!code ++]
import * as jwt from 'hono/jwt' // [!code ++]
import { Porto, ServerActions } from 'porto' // [!code ++]
import { ServerClient } from 'porto/viem' // [!code ++]
import { hashMessage } from 'viem' // [!code ++]
import { generateSiweNonce, parseSiweMessage } from 'viem/siwe' // [!code ++]

const app = new Hono().basePath('/api')
const porto = Porto.create()

app.post('/siwe/nonce', (c) => c.text(generateSiweNonce()))

app.post('/siwe/verify', async (c) => { 
  const { message, signature } = await c.req.json() // [!code ++]
  const { address, chainId, nonce } = parseSiweMessage(message) // [!code ++]

  // Verify the signature. // [!code ++]
  const client = ServerClient.fromPorto(porto, { chainId }) // [!code ++]
  const valid = ServerActions.verifySignature(client, { // [!code ++]
    address: address!, // [!code ++]
    digest: hashMessage(message), // [!code ++]
    signature, // [!code ++]
  }) // [!code ++]

  // If the signature is invalid, we cannot authenticate the user. // [!code ++]
  if (!valid) return c.json({ error: 'Invalid signature' }, 401) // [!code ++]

  // Issue a JWT for the user in a HTTP-only cookie. // [!code ++]
  const token = await jwt.sign({ sub: address }, c.env.JWT_SECRET) // [!code ++]
  setCookie(c, 'auth', token, { // [!code ++]
    httpOnly: true, // [!code ++]
    secure: true, // [!code ++]
  }) // [!code ++]

  // If the signature is valid, we can authenticate the user. // [!code ++]
  return c.json({ message: 'Authenticated' }) // [!code ++]
})

app.post('/siwe/logout', async (c) => { /* ... */ })

app.get('/me', async (c) => { /* ... */ })

export default app
```

### Done

Now that you have set up your `/api/siwe` endpoints and have your server up and running,
you can pass the `signInWithEthereum.authUrl` capability to the `connect` call to have
control over the authentication URL.

```tsx
import { useConnectors } from 'wagmi'
import { Hooks } from 'porto/wagmi'

export function Example() {
  const [connector] = useConnectors()
  const { connect } = Hooks.useConnect()

  return (
    <button 
      onClick={() => 
        connect({
          connector, 
          signInWithEthereum: { // [!code ++]
            authUrl: '/api/siwe', // [!code ++]
          }, // [!code ++]
        })
      }
    >
      Sign in
    </button>
  )
}
```

:::tip
If you wish to not group the authentication endpoints together (e.g. `/api/siwe/*`),
you can define them individually. This is useful if you are using a pre-existing server
with a different authentication routing structure.

```tsx
connect({
  connector,
  signInWithEthereum: {
    authUrl: '/api/siwe', // [!code --]
    authUrl: { // [!code ++]
      logout: '/api/logout', // [!code ++]
      nonce: '/api/auth/nonce', // [!code ++]
      verify: '/api/auth', // [!code ++]
    }, // [!code ++]
  },
})
```

:::

### Bonus: Add `/me` (authenticated route)

We can now add an authenticated routes to our app that can only be accessed if the user is authenticated.

In this example, we are using the `hono/jwt` middleware to check if the user is authenticated (they hold a valid `auth` cookie).

```tsx
import { Hono } from 'hono'
import { jwt } from 'hono/jwt'
import { Porto } from 'porto'

const app = new Hono().basePath('/api')
const porto = Porto.create()

app.get(
  '/me', 
  jwt({ cookie: 'auth' }), // [!code ++]
  async (c) => {
    return c.json({ user: 'John Doe' }) // [!code ++]
  }
)
```

### Bonus: Add `/siwe/logout`

We can also log out a user by deleting the `auth` cookie with `hono/cookie`'s `deleteCookie` function.

```tsx
import { Hono } from 'hono'
import { deleteCookie } from 'hono/cookie' // [!code ++]
import { jwt } from 'hono/jwt'
import { Porto } from 'porto'

const app = new Hono().basePath('/api')
const porto = Porto.create()

app.post(
  '/logout', 
  jwt({ cookie: 'auth' }),
  async (c) => {
    deleteCookie(c, 'auth') // [!code ++]
    return c.text('So long, friend.') // [!code ++]
  }
)
```
