#!/usr/bin/env bun

import { watch } from 'node:fs'
import { parseArgs } from 'node:util'
import type { PortoTheme } from './porto-theme.js'

const GENERATED_BY = 'file generated by apps/theme/export-theme.ts'

const SURFACE_VARIANTS = [
  'error',
  'info',
  'negative',
  'plane',
  'positive',
  'secondary',
  'strong',
  'warning',
  'alt',
] as const
const SURFACE_STATES = ['hovered', 'focused', 'pressed'] as const
const SURFACE_PARTS = ['background', 'content', 'border', 'radius'] as const

const STANDALONE_COLORS = ['accent', 'focus', 'link', 'separator'] as const
const STANDALONE_RADIUS = [
  'radiusSmall',
  'radiusMedium',
  'radiusLarge',
] as const

type Entries<T> = { [K in keyof T]: [K, T[K]] }[keyof T][]

function isThemeColor(value: unknown): value is [string, string, string] {
  return Array.isArray(value) && value.length === 3
}

function isThemeNumber(value: unknown): value is [string, number] {
  return (
    Array.isArray(value) && value.length === 2 && typeof value[1] === 'number'
  )
}

let args: ReturnType<typeof parseArgs>
try {
  args = parseArgs({
    allowPositionals: true,
    args: Bun.argv,
    options: {
      as: {
        default: 'css',
        type: 'string',
      },
      help: {
        default: false,
        short: 'h',
        type: 'boolean',
      },
      'no-confirm': {
        default: false,
        type: 'boolean',
      },
      out: {
        default: '',
        short: 'o',
        type: 'string',
      },
      watch: {
        default: false,
        short: 'w',
        type: 'boolean',
      },
    },
    strict: true,
  })
} catch (error) {
  console.error('\nError parsing arguments:\n')
  throw error
}

function cssVars(theme: PortoTheme, prefix = '--') {
  const vars: Record<string, { description?: string; value?: string }> = {}
  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const varName = `${prefix}${camelCaseToKebabCase(key)}`
    const data = cssVarValue(value)

    if (data) {
      vars[varName] = data
    }
  }
  return vars
}

function tailwindCssVars(theme: PortoTheme, prefix = '--') {
  const vars: Record<string, { description?: string; value?: string }> = {}
  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const varName = formatTailwindVarName(key, prefix)
    const data = cssVarValue(value)

    if (data) {
      vars[varName] = data
    }
  }
  return vars
}

function cssVarValue(value: unknown): {
  description: string
  value: string
} | null {
  if (isThemeColor(value)) {
    return {
      description: value[0],
      value: `light-dark(${cssValue(value[1])}, ${cssValue(value[2])})`,
    }
  }
  if (isThemeNumber(value)) {
    return {
      description: value[0],
      value: cssValue(value[1]),
    }
  }
  throw new Error(`Invalid theme value: ${JSON.stringify(value)}`)
}

function cssValue(value: string | number): string {
  if (typeof value === 'string' && value.startsWith('#'))
    return value.toLowerCase()
  return typeof value === 'number' ? `${value}px` : value
}

function camelCaseToKebabCase(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()
}

// Splits a surface name into components:
// - surface: the main color name
// - variant: optional variant (e.g. "error", "info")
// - state: optional state (e.g. "hovered", "focused")
// - part: the part of the theme (e.g. "background", "content", "border", "radius", "other")
// - partVariant: optional additional variant for the part (e.g "secondary", "tertiary")
function parseSurface(colorName: string): {
  surface: string
  variant?: string
  state?: string
  part: 'background' | 'content' | 'border' | 'radius' | 'other'
  partVariant?: string
} {
  const parts: string[] = []
  let current = ''

  for (const [index, char] of colorName.split('').entries()) {
    const isUpperCase = char === char.toUpperCase()

    if (index === 0 || !isUpperCase) {
      current += char
      continue
    }

    parts.push(current.toLowerCase())
    current = char
  }
  if (current) parts.push(current.toLowerCase())

  let part: 'background' | 'content' | 'border' | 'radius' | 'other' = 'other'
  let partIndex = -1

  for (const partName of SURFACE_PARTS) {
    if (parts.includes(partName)) {
      part = partName
      partIndex = parts.indexOf(partName)
      break
    }
  }

  if (part === 'other') {
    return {
      part: 'other',
      surface: colorName.toLowerCase(),
    }
  }

  const beforePart = parts.slice(0, partIndex)
  const afterPart = parts.slice(partIndex + 1)
  const surface = partIndex === 0 ? afterPart[0] || '' : beforePart[0] || ''

  const state = parts.find((p) =>
    SURFACE_STATES.includes(p as (typeof SURFACE_STATES)[number]),
  )
  const variant = parts.find((p) => {
    return (
      SURFACE_VARIANTS.includes(p as (typeof SURFACE_VARIANTS)[number]) &&
      // only treat something as a variant if it's not the surface name itself
      p !== surface
    )
  })

  // filter out names that are already identified as state or variant
  const remainingAfterPart = afterPart.filter(
    (p) => p !== state && p !== variant,
  )

  const partVariant =
    remainingAfterPart.length > 0 ? remainingAfterPart.join('') : undefined

  return { part, partVariant, state, surface, variant }
}

function formatTailwindVarName(colorName: string, prefix: string): string {
  if (STANDALONE_RADIUS.includes(colorName as any)) {
    const size = colorName.replace('radius', '').toLowerCase()
    return `${prefix}radius-th_${size}`
  }

  if (STANDALONE_COLORS.includes(colorName as any)) {
    return `${prefix}color-th_${colorName}`
  }

  const parsed = parseSurface(colorName)

  let varName = prefix
  if (parsed.part === 'background') varName += 'background-color-th_'
  else if (parsed.part === 'content') varName += 'text-color-th_'
  else if (parsed.part === 'border') varName += 'border-color-th_'
  else if (parsed.part === 'radius') varName += 'radius-th_'
  else if (parsed.part === 'other') varName += 'color-th_'

  const varNameParts = [parsed.surface]
  if (parsed.variant) varNameParts.push(parsed.variant.toLowerCase())
  if (parsed.state) varNameParts.push(parsed.state.toLowerCase())
  if (parsed.partVariant) varNameParts.push(parsed.partVariant.toLowerCase())

  varName += varNameParts.filter(Boolean).join('-')

  return varName
}

function generateMdx(theme: PortoTheme): string {
  const lines: string[] = [
    `{/* ${GENERATED_BY} */}

# Theme

See the \`theme\` option of [Mode.dialog](/sdk/api/mode#modedialog) to learn how to use custom themes with Porto. When using a custom theme with \`Mode.dialog\`, all properties but \`colorScheme\` are optional and will fall back to the default theme values.

Theme related types exported by \`porto/theme\`:

| Theme value type | Description |
|-|-|
| \`Theme.Color\` | A color value, either a hex color (with or without alpha) or \`"transparent"{:ts}\`. e.g. \`"#ff00ff"{:ts}\` |
| \`Theme.LightDarkColor\` | A color pair for light and dark modes. Individual values are \`Theme.Color\`. e.g. \`["#ff00ff", "#00ff00"]{:ts}\` |
| \`ThemeFragment\` | A partial \`Theme\` definition, used to extend themes with partial definitions. This is what gets passed to \`Mode.dialog\` as the \`theme\` option. |

## colorScheme

- **Type:** \`"light" | "dark" | "light dark"{:ts}\`

The color scheme for the theme. With \`"light dark"\`, theme colors must be provided as \`Theme.LightDarkColor\` (light and dark color pairs). Otherwise, colors must be provided as \`Theme.Color\`.
`,
  ]

  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const description = Array.isArray(value) ? value[0] : 'Theme token'
    lines.push(`## ${key}`)
    lines.push('')

    if (isThemeColor(value)) {
      lines.push('- **Type:** \`Theme.LightDarkColor | Theme.Color{:ts}\`')
      lines.push(`- **Default:** \`["${value[1]}", "${value[2]}"]{:ts}\``)
    } else if (isThemeNumber(value)) {
      lines.push(`- **Default:** \`${value[1]}{:ts}\``)
    }

    lines.push('')
    lines.push(description)
    lines.push('')
  }

  return lines.join('\n')
}

function generateSvg(theme: PortoTheme) {
  const colors = Object.entries(theme)
    .filter(([name, value]) => name !== 'colorScheme' && isThemeColor(value))
    .map(([name, value]) => ({
      darkValue: value[2] as `#${string}`,
      description: value[0],
      lightValue: value[1] as `#${string}`,
      name,
    }))

  const colorPairWidth = 280
  const colorPairHeight = 40
  const colorSectionHeight = colorPairHeight + 35 // title + more spacing

  const padding = 60
  const headerHeight = 40
  const svgWidth = colorPairWidth + padding * 2
  const svgHeight =
    headerHeight + colors.length * colorSectionHeight + padding * 2

  let svg = `<!-- ${GENERATED_BY} -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}">
<defs>
<style>
  text { font-family: sans-serif; }
</style>
</defs>
<rect width="100%" height="100%" fill="#fafafa" />
<text x="${padding}" y="${padding}" font-size="16px" font-weight="bold" fill="#333">Porto Theme</text>
<g transform="translate(${padding}, ${headerHeight + padding})">
`
  for (const [index, color] of colors.entries()) {
    const y = index * colorSectionHeight
    const halfWidth = colorPairWidth / 2

    svg += `<g transform="translate(0, ${y})">`
    svg += `<text x="0" y="12" font-size="12px" fill="#333" font-weight="bold">${color.name}</text>`
    svg += `<g transform="translate(0, 20)">`

    const lightTextFill =
      colorIntensity(color.lightValue as `#${string}`) === 'high'
        ? '#000000'
        : '#ffffff'
    svg += `<rect class="color" x="0" y="0" width="${halfWidth}" height="${colorPairHeight}" fill="${color.lightValue}" stroke="none" />`
    svg += `<text x="8" y="16" font-size="10px" fill="${lightTextFill}">light</text>`
    svg += `<text x="8" y="28" font-size="9px" fill="${lightTextFill}">${color.lightValue}</text>`

    const darkTextFill =
      colorIntensity(color.darkValue as `#${string}`) === 'high'
        ? '#000000'
        : '#ffffff'
    svg += `<rect class="color" x="${halfWidth}" y="0" width="${halfWidth}" height="${colorPairHeight}" fill="${color.darkValue}" rx="0 6 6 0" />`
    svg += `<text x="${halfWidth + 8}" y="16" font-family="monospace" font-size="10px" fill="${darkTextFill}">dark</text>`
    svg += `<text x="${halfWidth + 8}" y="28" font-family="monospace" font-size="9px" fill="${darkTextFill}">${color.darkValue}</text>`

    svg += '</g></g>'
  }
  svg += '</g></svg>'
  return svg
}

function generateTailwindMappings(theme: PortoTheme): string {
  const mappings: string[] = []

  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const tailwindVar = formatTailwindVarName(key, '--')
    const type = isThemeNumber(value) ? 'px' : 'color'

    mappings.push(`  ['${key}', '${tailwindVar}', '${type}'],`)
  }

  return `/* ${GENERATED_BY} */

export type TailwindThemeMapping = [property: string, tailwindVar: string, type: 'color' | 'px']

export const tailwindThemeMappings: TailwindThemeMapping[] = [
${mappings.join('\n')}
]
`
}

function css(
  theme: PortoTheme,
  {
    comments,
    nestIn,
    prefix = '',
  }: {
    comments?: boolean
    nestIn?: string
    prefix?: string
  } = {},
) {
  const padding = nestIn ? '  ' : ''

  let cssContent = `/* ${GENERATED_BY} */\n`

  if (nestIn) cssContent += `\n${nestIn} {\n`
  cssContent += Object.entries(cssVars(theme, prefix))
    .map(([key, { value, description }]) => {
      return (
        (comments && description ? `${padding}/* ${description} */\n` : '') +
        `${padding}${key}: ${value};`
      )
    })
    .join(comments ? '\n\n' : '\n')

  if (nestIn) cssContent += '\n}'

  return cssContent
}

function tailwindCss(
  theme: PortoTheme,
  {
    comments,
  }: {
    comments?: boolean
  } = {},
) {
  const padding = '  '

  let cssContent = `/* ${GENERATED_BY} */\n\n@theme {\n`

  const vars = tailwindCssVars(theme, '--')
  cssContent += Object.entries(vars)
    .map(([key, { value, description }]) => {
      return (
        (comments && description ? `${padding}/* ${description} */\n` : '') +
        `${padding}${key}: ${value};`
      )
    })
    .join(comments ? '\n\n' : '\n')

  cssContent += '\n}'

  return cssContent
}

const formatExporters = {
  css(theme) {
    return css(theme, {
      comments: false,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  css_commented(theme) {
    return css(theme, {
      comments: true,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  json(theme) {
    const themeOnly = Object.fromEntries(
      Object.entries(theme).map(([key, value]) => {
        if (key === 'colorScheme') return [key, value]
        if (isThemeColor(value)) {
          return [key, [value[1], value[2]]]
        }
        if (isThemeNumber(value)) {
          return [key, value[1]]
        }
        return [key, value]
      }),
    )
    return JSON.stringify(themeOnly, null, 2)
  },
  mdx(theme) {
    return generateMdx(theme)
  },
  svg(theme) {
    return generateSvg(theme)
  },
  tailwind(theme) {
    return tailwindCss(theme, { comments: false })
  },
  tailwind_commented(theme) {
    return tailwindCss(theme, { comments: true })
  },
  tailwind_mappings(theme) {
    return generateTailwindMappings(theme)
  },
} satisfies Record<string, (theme: PortoTheme) => string>

if (args.values.help) {
  console.log(`
Usage: export-theme.ts [options]

Options:
  --as <format>      Output format (default: css).
                     Supported formats: ${Object.keys(formatExporters).join(', ')}.
  --help, -h         Show this help message.
  --out              File to write the exported theme to. Prints to stdout if not specified.
  --watch, -w        Watch for changes and re-export the theme. Requires an output file.
`)
  process.exit(0)
}

const isValidExporter = (as: unknown): as is keyof typeof formatExporters => {
  return typeof as === 'string' && Object.keys(formatExporters).includes(as)
}

if (!isValidExporter(args.values.as)) {
  console.error(
    `Invalid format: ${args.values.as}. Supported formats: ${Object.keys(formatExporters).join(', ')}.`,
  )
  process.exit(1)
}

const outPath =
  (typeof args.values.out === 'string' && args.values.out.trim()) || null

async function exportTheme(confirmIfExists = true) {
  if (!isValidExporter(args.values.as)) throw new Error() // type guard

  delete require.cache[require.resolve('./porto-theme.js')]
  const { portoTheme } = await import('./porto-theme.js')

  const exporter = formatExporters[args.values.as]
  const output = exporter(portoTheme)

  if (outPath) {
    const file = Bun.file(outPath)
    if (await file.exists()) {
      const shouldOverwrite =
        confirmIfExists && !args.values['no-confirm']
          ? confirm(`File ${outPath} already exists. Overwrite?`)
          : true
      if (!shouldOverwrite) {
        console.error('Export cancelled.')
        return
      }
    }

    await Bun.write(outPath, output)
    console.log(`Theme exported to ${outPath} in ${args.values.as} format.`)
  } else {
    console.log(output)
  }
}

if (args.values.watch) {
  const stdoutMode = outPath === null
  if (stdoutMode) console.clear()

  exportTheme()

  if (!stdoutMode) console.log('Watching for changes…')

  watch('./porto-theme.ts', async (eventType, filename) => {
    if (eventType === 'change') {
      if (stdoutMode) console.clear()
      else console.log(`\n${filename} changed, re-exporting…`)
      try {
        await exportTheme(false)
      } catch (error) {
        console.error('Error re-exporting theme:', error)
      }
    }
  })
} else {
  exportTheme()
}

// thanks https://stackoverflow.com/a/3943023
function colorIntensity(hex: `#${string}`): 'high' | 'low' {
  if (!/^#[0-9A-Fa-f]{6,8}$/.test(hex))
    throw new Error(`Invalid hex color: ${hex}`)
  const [r, g, b] = [
    Number.parseInt(hex.slice(1, 3), 16),
    Number.parseInt(hex.slice(3, 5), 16),
    Number.parseInt(hex.slice(5, 7), 16),
  ]
  const intensity = r * 0.299 + g * 0.587 + b * 0.114
  return intensity > 186 ? 'high' : 'low'
}
